# Maxitter

MaximumメンバーがWeb研究部の活動として、Twitterのようなマイクロブログサービス作りを通して共同開発・Webアプリケーション開発の経験を積むことを目的としたプロジェクトです。

## 開発環境

- Docker (Docker Compose)
  - Nginx
  - MySQL (db)
  - Go (back)
  - React (front)

## 開発形態

- ブランチモデル
  - production (本番環境)
  - development (ステージング環境)
  - feat/xxx (機能追加)
  - fix/xxx (バグ修正)
  - hotfix/xxx (緊急バグ修正)

## 開発手順

### 最初

1. リポジトリをクローンする `git clone https://github.com/saitamau-maximum/maxitter.git`
2. `cd maxitter`でフォルダに移動
3. `cp .env.example .env`で.envファイルを作成
4. `.env`ファイルを自分の好きな名前やパスワードに書き換え
5. `./scripts/setup.sh` でビルドしてコンテナを起動する

### 停止

`./scripts/stop.sh` でコンテナを停止する

### 再開

`./scripts/start.sh` でコンテナを再開する

### DBデータの削除

`./scripts/reset-db.sh` でDBデータを削除する

### DBのマイグレーション

> [!IMPORTANT]
> マイグレーションを初めて実行する場合、まずはデータベースのデータを削除する必要があります。これは、上記の「[DBデータの削除](#dbデータの削除)」にあるコマンドを使用して行えます。
> データの削除が完了したら、 `./scripts/migrator.sh init` を実行して、マイグレーションを行うための必要な情報をDB上に作成することができます。
> 詳しくは「[データベースのマイグレーションとモデル](#データベースのマイグレーションとモデル)」を参照してください。

- `./scripts/migrator.sh migrate` を実行することで、データベースのスキーマを最新の状態に更新できる

- `./scripts/migrator.sh rollback` を実行することで、データベースのスキーマを1つ前の状態に戻すことができる

- `./scripts/migrator.sh create_go <任意のコメント>` を実行することで、新しいマイグレーションを作成できる

- `./scripts/migrator.sh status`を実行することで、現在のマイグレーションの状態を確認できる

(他にもコマンドがありますが、詳しくは[この記事](https://zenn.dev/suetak/articles/5b3110358645b7)に書いてあるので確認してみてください。)

### デプロイ

`./scripts/deploy.sh` で本番環境にデプロイする
（マイグレーションなど特別なオペレーションが必要な場合もある）

## バックエンド処理の構造と役割

backend 配下は次のようなディレクトリとファイルで構成されています。

- `cmd`: このディレクトリは、アプリケーションが始まる場所で、Goのmain関数が含まれています。ここには、例えばmigrateとserverという2つのサブディレクトリがあります。`cmd/server/main.go`は、サーバーを起動するためのプログラムで、アプリケーションが始まるときに最初に実行されます。一方、`cmd/migrate/main.go`は、データベースの構造（スキーマ）を更新するためのマイグレーションを実行するプログラムで、これは`scripts/migrator.sh`によって実行されます。これらのプログラムは、アプリケーションの動作とデータの管理を制御します。
- `Dockerfile`: このファイルは、アプリケーションのDockerイメージをビルドするための指示を含んでいます。
- `external`: このディレクトリには、外部サービスとのインターフェースが含まれています。例えば、`discord.go`はDiscordとの通信を処理します。
- `handler`: このディレクトリには、HTTPリクエストを処理するためのハンドラが含まれています。
- `migrations`: このディレクトリには、データベースのマイグレーションが含まれています。これらのマイグレーションは、データベースのスキーマを変更するために使用されます。
- `model`: このディレクトリには、データベースのテーブルを表すGoの構造体が含まれています。これらの構造体は、データベースとのやり取りを容易にします。
- `public`: このディレクトリには、公開される静的ファイルが含まれています。

## データベースのマイグレーションとモデル

データベースのマイグレーションは、データベースのスキーマを管理する手段です。新しいテーブルを追加したり、既存のテーブルを変更したい場合は、マイグレーションを作成して実行します。

マイグレーションは`migrations`ディレクトリ内のGoファイルに記述されます。各マイグレーションファイルには、「アップ」操作と「ダウン」操作が含まれています。アップ操作はマイグレーションを適用するための操作を定義し、ダウン操作はマイグレーションをロールバックするための操作を定義します。

データベースのモデルは`model`ディレクトリ内のGoファイルに定義されます。各モデルはデータベースのテーブルを表すGoの構造体です。これらのモデルはデータベースとのやり取りを容易にします。

### 新しいカラムやテーブルを追加する

新しいカラムを追加する場合、対応するモデルのGo構造体に新しいフィールドを追加します。次に、新しいマイグレーションを作成して、データベースのテーブルに新しいカラムを追加します。

新しいテーブルを追加するには、新しいモデルのGo構造体を作成します。次に、新しいマイグレーションを作成して、新しいテーブルをデータベースに追加します。

これらの操作は、`scripts/migrator.sh`を使用して行います。詳細な手順は以下の通りです。

1. **モデルの作成**: `model`ディレクトリに新しいGoファイルを作成します。このファイルには、新しいテーブルを表すGoの構造体を定義します。

2. **マイグレーションの作成**: `./scripts/migrator.sh create_go <任意のコメント>`を実行して、マイグレーション用のGoファイルを作成します。コメントはGitのコミットメッセージのように、「create users table」などと更新内容が分かりやすいと良いです。実行すると、`migrations`ディレクトリに日時と指定したコメントが合わさったような名前のGoファイルが作成されます。例えば、 `./scripts/migrator.sh create_go create initial tables` を実行して`migrations`ディレクトリに`20231109002750_create_initial_tables.go`を作成しました。

3. **マイグレーションの処理**: 作成されたGoファイルにマイグレーションの処理を書きます。例えば、`20231109002750_create_initial_tables.go`では以下のようなup migrationの処理を書いています。

    ```go
    fmt.Print(" [up migration] ")
    _, err := db.NewCreateTable().Model((*model.Post)(nil)).Exec(ctx)
    if err != nil {
      return err
    }
    _, err = db.NewCreateTable().Model((*model.User)(nil)).Exec(ctx)
    return err
    ```
    
    これは`model/post.go`と`model/user.go`に定義されているモデルをデータベースに追加する処理です。このように、Bunのmigration機能では実際にアップデートの処理を手動でup migrationに書く必要があります。

    また、down migrationの処理はup migrationの処理を完全に打ち消せるように書きます。
    例えば、`20231109002750_create_initial_tables.go`ではup migrationで`posts`テーブルと`users`テーブルを作成します。よって、down migrationではこれらのテーブルを削除するような処理を書きます。

    ```go
    fmt.Print(" [down migration] ")
    _, err := db.NewDropTable().Model((*model.Post)(nil)).IfExists().Exec(ctx)
    if err != nil {
      return err
    }
    _, err = db.NewDropTable().Model((*model.User)(nil)).IfExists().Exec(ctx)
    return err
    ```

    このようにすることでマイグレーションをロールバックすることができるようになるため、バージョン管理が容易になるというメリットがあります。

4. **マイグレーションの実行**: `./scripts/migrator.sh migrate`を実行して、新しいマイグレーションを適用します。

以上の手順により、新しいカラムやテーブルをデータベースに追加することができます。

より具体的な操作は[この記事](https://zenn.dev/suetak/articles/5b3110358645b7)に説明があるので、参考にしてみてください。


## スプリント

毎週月曜日にあるWeb研究会の講義の間を1スプリントと定義する。

## バージョニング

バージョンは1スプリントでマイナーバージョン x.X.x を上げることにする。
それよりも細かい単位の変更（スプリント中だけど緊急で修正箇所が浮上したなど）でリリースが必要な場合、パッチバージョン x.x.X を上げることにする。

メジャーバージョンに関しては区切りが良くなったタイミングであげるで良い。
